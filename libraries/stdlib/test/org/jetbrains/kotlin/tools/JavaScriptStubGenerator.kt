package org.jetbrains.kotlin.tools

import java.io.File
import org.w3c.dom.Element
import kotlin.dom.parseXml
import kotlin.dom.iterator
import java.io.FileOutputStream
import org.w3c.dom.Node
import java.util.HashMap
import java.util.HashSet

private fun Element.attribute(name: String): String? {
    val value = getAttribute(name)!!
    return if (value.isEmpty()) null else value
}

fun generateApi(packageName: String, idlFile: File, outFile: File, ignoredClasses: Set<String>? = null) {
    val generator = JavaScriptStubGenerator(packageName)
    generator.generate(idlFile, ignoredClasses)
    generator.writeTo(outFile)
}

class JavaScriptStubGenerator(packageName: String) {
    private val builder = StringBuilder("//\n// NOTE THIS FILE IS AUTO-GENERATED by the GenerateJavaScriptStubs.kt\n//\n\npackage $packageName")
    private var classNameToEndOffset = HashMap<String, Int>()
    private val propertyDuplicateGuard = HashSet<String>()

    private var currentClassName: String? = null

    private fun findConstructor(classElement: Element): Element? {
        for (val node in classElement.getChildNodes()!!) {
            if (node is Element && node.getTagName() == "method" && node.getAttribute("name") == "__constructor__") {
                return node
            }
        }
        return null
    }

    fun append(string: String) {
        builder.append(string)
    }

    fun generate(idlFile: File, ignoredClasses: Set<String>? = null) {
        val document = parseXml(idlFile)
        for (val node in document.getDocumentElement()!!.iterator().filter { it is Element && it.getTagName() == "class" }) {
            val element = node as Element
            currentClassName = element.attribute("name")!!
            if (ignoredClasses != null && ignoredClasses.contains(currentClassName)) {
                continue
            }
            if (currentClassName == "window") {
                currentClassName = "Window"
            }
            else if (currentClassName == "document") {
                currentClassName = "Document"
            }

            val endOffset = classNameToEndOffset.get(currentClassName)
            val builder: StringBuilder
            if (endOffset == null) {
                builder = this.builder
                builder.append("\n\npublic native trait ").append(currentClassName)
                val constructor = findConstructor(element)
                if (constructor != null) {

                }

                val extends = element.attribute("extends")
                if (extends != null) {
                    builder.append(" : ").append(getType(extends))
                }
                builder.append(" {")
            }
            else {
                builder = StringBuilder()
                builder.append("\n")
            }

            val static = element.iterator().filter { it is Element && it.getTagName() == "static" }
            val hasStaticMemebers = static.hasNext()
            if (hasStaticMemebers) {
                builder.append("\n\tpublic class object {")
                processMembers(static.next() as Element, true, false, "\t\t", builder)
                builder.append("\n\t}")

                assert(!static.hasNext())
            }
            processMembers(element, false, hasStaticMemebers, "\t", builder)

            if (endOffset == null) {
                classNameToEndOffset.put(currentClassName!!, builder.length())
                builder.append("\n}")
                if (element.attribute("exposeAsProperty") == "true") {
                    builder.append("\n\npublic native val ").append(Character.toLowerCase(currentClassName!![0]))
                    builder.append(currentClassName!!, 1, currentClassName!!.length())
                    builder.append(": ").append(currentClassName).append(" = noImpl")
                }
            }
            else {
                val newClassNameToEndOffset = HashMap<String, Int>(classNameToEndOffset.size)
                for (entry in classNameToEndOffset) {
                    var v = entry.getValue()
                    if (v >= endOffset) {
                        v += builder.length()
                    }
                    newClassNameToEndOffset.put(entry.getKey(), v)
                }
                classNameToEndOffset = newClassNameToEndOffset
                this.builder.insert(endOffset, builder)
            }
        }
        currentClassName = null
    }

    fun writeTo(outFile: File) {
        val outStream = FileOutputStream(outFile)
        outStream.write(builder.toString().getBytes());
        outStream.close()
    }

    private fun checkElement(element: Node, tagName: String) = element is Element && element.getTagName() == tagName && element.attribute("deprecated") == null && element.attribute("browser") != "IE"

    fun processMembers(element: Element, static: Boolean, hasMembersBefore: Boolean, indent: String, builder: StringBuilder) {
        val nodes = element.getChildNodes()!!
        val properties = nodes.iterator().filter { checkElement(it, "property") && propertyDuplicateGuard.add(currentClassName + "." + (it as Element).attribute("name")!!) }
        val methods = nodes.iterator().filter { checkElement(it, "method") }
        val insertNewLineSeparator = properties.hasNext() && methods.hasNext()

        if (hasMembersBefore && (properties.hasNext() || methods.hasNext())) {
            builder.append('\n')
        }

        processProperties(properties, indent, builder)
        if (insertNewLineSeparator) {
            builder.append('\n')
        }
        processMethods(methods, static, indent, builder)
    }

    private fun processProperties(nodes: Iterator<Node>, indent: String, builder: StringBuilder) {
        for (val node in nodes) {
            val element = node as Element
            builder.append("\n${indent}public va")
            val readOnly = element.attribute("readOnly") == "true" || element.getAttribute("attribute")!!.equalsIgnoreCase("readonly")
            builder.append(if (readOnly) 'l' else 'r')
            builder.append(' ').appendName(element).appendType(element)

            val value = element.attribute("value")
            if (value != null) {
                builder.append(" = ").append(value)
            }
        }
    }

    private fun processMethods(nodes: Iterator<Node>, bodyRequired: Boolean, indent: String, builder: StringBuilder) {
        for (val node in nodes) {
            val element = node as Element
            val name = getName(element)
            if (name == "__constructor__") {
                continue
            }

            val parameters = element.iterator().filter { checkElement(it, "param") }.toList()
            var multiTypeParameterName: String? = null
            var multiTypeParameterTypes: Array<String>? = null
            for (val parameter in parameters) {
                val typeName = (parameter as Element).attribute("type")
                if (typeName == null) {
                    throw RuntimeException("type attribute missed for $currentClassName.$name")
                }

                if (typeName.indexOf('|') != -1) {
                    multiTypeParameterName = getName(parameter as Element)
                    multiTypeParameterTypes = typeName.split('|')
                    break
                }
            }

            var stopProcessParameters = true
            var multiParameterIndex = 0
            do {
                builder.append("\n${indent}public fun ").append(name).append('(')
                var first = true
                for (val parameterNode in parameters) {
                    if (first) {
                        first = false
                    }
                    else {
                        builder.append(", ")
                    }

                    val parameterElement = parameterNode as Element
                    val parameterName = getName(parameterElement)
                    var typeName: String
                    if (parameterName == multiTypeParameterName) {
                        typeName = getType(multiTypeParameterTypes!![multiParameterIndex++])
                        stopProcessParameters = multiParameterIndex == multiTypeParameterTypes!!.size
                    }
                    else {
                        typeName = getType(parameterElement)
                        // todo
                        if (typeName.indexOf('|') != -1) {
                            typeName = typeName.substring(0, typeName.indexOf('|'))
                        }
                    }
                    builder.appendName(parameterElement).append(": ")
                    val optional = parameterElement.getAttribute("mandatory") != "true"
                    val enclose = optional && typeName.indexOf('(') != -1
                    if (enclose) {
                        builder.append('(')
                    }
                    builder.append(typeName)
                    if (optional) {
                        if (enclose) {
                            builder.append(')')
                        }
                        builder.append("? = null")
                    }
                }

                builder.append(')').appendType(element, "returnType")
                if (bodyRequired) {
                    builder.append(" = ").append("noImpl")
                }
            }
            while (!stopProcessParameters)
        }
    }

    private fun processParameters(nodes: Iterator<Node>, builder: StringBuilder) {
        var first = true
        for (val node in nodes) {
            if (first) {
                first = false
            }
            else {
                builder.append(", ")
            }

            val element = node as Element
            builder.appendName(element).appendType(element)
            if (element.getAttribute("mandatory") != "true") {
                builder.append('?')
            }
        }
    }

    private fun getName(element: Element): String {
        val name = element.getAttribute("name")!!
        return when (name) {
            "type", "object" -> "`$name`"
            else -> name
        }
    }

    private fun StringBuilder.appendName(element: Element): StringBuilder {
        append(getName(element))
        return this
    }

    private fun StringBuilder.appendType(element: Element, attributeName: String = "type"): StringBuilder {
        append(": ").append(getType(element, attributeName))
        return this
    }

    private fun getType(element: Element, attributeName: String = "type"): String  = getType(element.attribute(attributeName))

    private fun getType(typeName: String?): String {
        return when (typeName) {
            "AbstractView" -> "html.AbstractView"
            "Range" -> "org.w3c.dom.Range"
            "long" -> "Long"
            "int" -> "Int"
            "byte" -> "Byte"
            "window" -> "Window"
            "document" -> "Document"
            "Error" -> "java.lang.Exception"
            "void", null -> "Unit"
            "Function" -> "()->Unit"
            "Array" -> "Array<Any>"
            "Object", "*" -> "Any"
            "\$__Type__$" -> currentClassName!!
            else -> {
                if (typeName.endsWith("[]")) {
                    "Array<${getType(typeName.substring(0, typeName.length - 2))}>"
                }
                else {
                    typeName
                }
            }
        }
    }
}