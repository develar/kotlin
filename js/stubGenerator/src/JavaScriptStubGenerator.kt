package org.jetbrains.kotlin.js.stubGenerator

import java.io.File
import org.w3c.dom.Element
import kotlin.dom.parseXml
import kotlin.dom.iterator
import java.io.FileOutputStream
import org.w3c.dom.Node
import java.util.HashMap
import java.util.HashSet
import java.util.regex.Matcher

private fun Element.attribute(name: String): String? {
    val value = getAttribute(name)!!
    return if (value.isEmpty()) null else value
}

fun generateApi(packageName: String, idlFile: File, outFile: File, ignoredClasses: Set<String>? = null) {
    val generator = JavaScriptStubGenerator(packageName)
    generator.generate(idlFile, ignoredClasses)
    generator.writeTo(outFile)
}

private val FUN_TYPE_PATTERN = "^function\\(\\{(?:([a-zA-Z0-9]+): *([\\(\\)a-zA-Z|]+)(?:, *)?)+\\}\\)$".toRegex()
private val FUN_TYPE_SIMPLE_PATTERN = "^function\\((?:(?:([a-zA-Z0-9]+): *)?([\\(\\)a-zA-Z|]+)(?:, *)?)*\\)(?::\\(([^)]+)\\))?$".toRegex()

class JavaScriptStubGenerator(packageName: String) {
    private val builder = StringBuilder("// NOTE THIS FILE IS AUTO-GENERATED by the JavaScriptStubGenerator\n\npackage $packageName")
    private var classNameToEndOffset = HashMap<String, Int>()
    private val propertyDuplicateGuard = HashSet<String>()

    private var currentClassName: String? = null
    private var methodParamMandatoryByDefault = false

    private var genericType: String? = null

    private fun findConstructor(classElement: Element): Element? {
        for ( node in classElement.getChildNodes()) {
            if (node is Element && node.getTagName() == "method" && node.getAttribute("name") == "__constructor__") {
                return node
            }
        }
        return null
    }

    fun append(string: String) {
        builder.append(string)
    }

    private fun processConstructor(parentElement: Element, builder: StringBuilder) {
        builder.append('(')
        var first = true
        for (node in parentElement.iterator().filter { checkElement(it, "param") }) {
            if (first) {
                first = false
            }
            else {
                builder.append(", ")
            }

            val element = node as Element
            processParameter(element, getType(element), builder, isOptional(element))
        }
        builder.append(')')
    }

    fun generate(idlFile: File, ignoredClasses: Set<String>? = null) {
        val document = parseXml(idlFile)
        for (node in document.getDocumentElement()!!.iterator().filter { it is Element && (it.getTagName() == "class" || it.getTagName() == "trait") }) {
            val element = node as Element
            currentClassName = element.attribute("name")!!
            if (ignoredClasses != null && ignoredClasses.contains(currentClassName)) {
                continue
            }
            if (currentClassName == "window") {
                currentClassName = "Window"
            }

            var isTrait = element.getTagName() == "trait"
            methodParamMandatoryByDefault = isTrait || element.getAttribute("paramPolicyMandatory") == "true"

            val endOffset = classNameToEndOffset.get(currentClassName)
            val builder: StringBuilder
            val genericOffset: Int?
            if (endOffset == null) {
                var extends = element.attribute("extends")
                if (extends == "Error") {
                    // don't translate js errors classes
                    continue
                }

                builder = this.builder

                val constructor = findConstructor(element)
                if (constructor == null) {
                    isTrait = true
                }

                builder.append("\n\npublic ")
                if (element.attribute("open") == "true") {
                    builder.append("open ")
                }
                builder.append(if (isTrait) "trait" else "class").append(' ').append(currentClassName)
                genericOffset = builder.length()
                if (constructor != null) {
                    processConstructor(constructor, builder)
                }

                if (extends == null && currentClassName!!.endsWith("Exception")) {
                    extends = "jet.Throwable"
                }
                if (extends != null) {
                    builder.append(" : ").append(getType(extends))
                    if (!isTrait) {
                        append("()")
                    }
                }

                val implements = element.attribute("implements")
                if (implements != null) {
                    builder.append(if (extends == null) " : " else ", ")
                    builder.append(getType(implements))
                }
                builder.append(" {")
            }
            else {
                genericOffset = null
                builder = StringBuilder()
                builder.append("\n")

                isTrait = true
            }

            val static = element.iterator().filter { it is Element && it.getTagName() == "static" }
            val hasStaticMembers = static.hasNext()
            if (hasStaticMembers) {
                builder.append("\n\tpublic class object {")
                processMembers(static.next() as Element, false, "\t\t", builder)
                builder.append("\n\t}")

                assert(!static.hasNext())
            }
            processMembers(element, !isTrait, "\t", builder)

            if (genericType != null) {
                builder.insert(genericOffset!!, "<$genericType>")
                genericType = null
            }

            if (endOffset == null) {
                classNameToEndOffset.put(currentClassName!!, builder.length())
                builder.append("\n}")
                val exposeAsProperty = element.attribute("exposeAsProperty")
                if (exposeAsProperty != null && exposeAsProperty != "false") {
                    builder.append("\n\npublic val ")
                    if (exposeAsProperty == "true") {
                        builder.append(Character.toLowerCase(currentClassName!![0]))
                        builder.append(currentClassName!!, 1, currentClassName!!.length())
                    }
                    else {
                        builder.append(exposeAsProperty)
                    }
                    builder.append(": ").append(currentClassName)
                }
            }
            else {
                updateClassOffsets(endOffset, builder.length())
                this.builder.insert(endOffset, builder)
            }
        }
        currentClassName = null
    }

    private fun updateClassOffsets(endOffset: Int, increment: Int) {
        val newClassNameToEndOffset = HashMap<String, Int>(classNameToEndOffset.size)
        for (entry in classNameToEndOffset) {
            var v = entry.getValue()
            if (v >= endOffset) {
                v += increment
            }
            newClassNameToEndOffset.put(entry.getKey(), v)
        }
        classNameToEndOffset = newClassNameToEndOffset
    }

    fun writeTo(outFile: File) {
        val outStream = FileOutputStream(outFile)
        outStream.write(builder.toString().getBytes());
        outStream.close()
    }

    private fun checkElement(element: Node, tagName: String) = element is Element && element.getTagName() == tagName && element.attribute("deprecated") == null && element.attribute("browser") != "IE"

    fun processMembers(element: Element, hasMembersBefore: Boolean, indent: String, builder: StringBuilder) {
        val nodes = element.getChildNodes()
        val properties = nodes.iterator().filter { checkElement(it, "property") && propertyDuplicateGuard.add(currentClassName + "." + (it as Element).attribute("name")!!) }
        val methods = nodes.iterator().filter { checkElement(it, "method") }
        val insertNewLineSeparator = properties.hasNext() && methods.hasNext()

        if (hasMembersBefore && (properties.hasNext() || methods.hasNext())) {
            builder.append('\n')
        }

        processProperties(properties, indent, builder)
        if (insertNewLineSeparator) {
            builder.append('\n')
        }
        processMethods(methods, indent, builder)
    }

    private fun StringBuilder.appendGeneratedEventName(propertyName: String, firstChar: Char): StringBuilder {
        append(firstChar).append(propertyName, 3, propertyName.length).append("Event")
        return this
    }

    private fun processTypeExpression(matcher: Matcher, processor: (propertyName: String?, propertyType: String)->Unit): String? {
        matcher.matches()
        val n = matcher.groupCount()
        assert(n > 0)
        var i = 1
        while (i < n) {
            val propertyName = matcher.group(i++)
            val propertyType = matcher.group(i++)
            // function(<there is no parameters>):(void|Boolean)
            if (propertyType != null) {
                processor(propertyName, propertyType)
            }
        }
        return matcher.group(n)
    }

    private fun processProperties(nodes: Iterator<Node>, indent: String, builder: StringBuilder) {
        for (node in nodes) {
            val element = node as Element

            var typeName = getType(element)
            val name = getName(element)
            var typeNameAppender: ()->Unit = {
                builder.append(typeName)
            }

            if (typeName.startsWith("function(")) {
                val simple = typeName["function(".length] != '{'
                val matcher = (if (simple) FUN_TYPE_SIMPLE_PATTERN else FUN_TYPE_PATTERN).matcher(typeName)
                if (!simple) {
                    val firstChar = Character.toUpperCase(name[2])
                    builder.append("\n\n${indent}public abstract inner class ").appendGeneratedEventName(name, firstChar).append(" : org.w3c.dom.Event {")
                    processTypeExpression(matcher) {propertyName, propertyType ->
                        val effectiveType: String
                        if (propertyType.contains("|")) {
                            effectiveType = "T"
                            genericType = "T: Any"
                        }
                        else {
                            effectiveType = propertyType
                        }
                        builder.append("\n${indent}\tpublic val ").append(propertyName!!).append(": ").append(effectiveType)
                    }
                    builder.append("\n${indent}}")
                    typeNameAppender = {
                        builder.append("(event: ").appendGeneratedEventName(name, firstChar).append(")->Unit")
                    }
                }
                else {
                    typeNameAppender = {
                        builder.append("(")
                        var first = true
                        val returnType = processTypeExpression(matcher) {propertyName, propertyType ->
                            if (first) {
                                first = false
                            }
                            else {
                                builder.append(", ")
                            }
                            builder.append(if (propertyType != "Event") getType(propertyType) else "org.w3c.dom.Event")
                        }
                        builder.append(")->").append(if (returnType == null) "Unit" else "Any")
                    }
                }
            }
            else {
                typeName = getType(typeName)
                if (typeName.contains("|")) {
                    typeName = "Any"
                }
            }

            builder.append("\n${indent}public va")
            val readOnly = element.attribute("readOnly") == "true" || element.getAttribute("attribute")!!.equalsIgnoreCase("readonly")
            builder.append(if (readOnly) 'l' else 'r')
            builder.append(' ').appendName(element).append(": ")
            typeNameAppender()

            val value = element.attribute("value")
            if (value != null) {
                builder.append(" = ").append(value)
            }
        }
    }

    private fun processMethods(nodes: Iterator<Node>, indent: String, builder: StringBuilder) {
        for (node in nodes) {
            val element = node as Element
            val name = getName(element)
            if (name == "__constructor__") {
                continue
            }

            val parameters = element.iterator().filter { checkElement(it, "param") }.toList()
            var multiTypeParameterName: String? = null
            var multiTypeParameterTypes: Array<String>? = null
            for (parameter in parameters) {
                val typeName = (parameter as Element).attribute("type")
                if (typeName == null) {
                    throw RuntimeException("type attribute missed for $currentClassName.$name")
                }

                if (typeName.indexOf('|') != -1) {
                    multiTypeParameterName = getName(parameter as Element)
                    multiTypeParameterTypes = typeName.split('|')
                    break
                }
            }

            var stopProcessParameters = true
            var multiParameterIndex = 0
            do {
                builder.append("\n${indent}public fun ").append(name).append('(')
                var first = true
                for (parameterNode in parameters) {
                    if (first) {
                        first = false
                    }
                    else {
                        builder.append(", ")
                    }

                    val parameterElement = parameterNode as Element
                    val parameterName = getName(parameterElement)
                    var typeName: String
                    if (parameterName == multiTypeParameterName) {
                        typeName = getType(multiTypeParameterTypes!![multiParameterIndex++])
                        stopProcessParameters = multiParameterIndex == multiTypeParameterTypes!!.size
                    }
                    else {
                        typeName = getType(parameterElement)
                        // todo
                        if (typeName.indexOf('|') != -1) {
                            typeName = typeName.substring(0, typeName.indexOf('|'))
                        }
                    }
                    // <param name="data" type="String|ArrayBuffer|Blob|Document|FormData" optional="true"/>, see XMLHttpRequest.send
                    val optional = multiParameterIndex <= 1 && isOptional(parameterElement)
                    processParameter(parameterElement, typeName, builder, optional)
                }

                builder.append(')').appendType(element, "returnType")
            }
            while (!stopProcessParameters)
        }
    }

    private fun isOptional(element: Element) = if (methodParamMandatoryByDefault) element.getAttribute("optional") == "true" else element.getAttribute("mandatory") != "true"

    private fun processParameter(element: Element, typeName: String, builder: StringBuilder, optional: Boolean) {
        val rest = element.attribute("rest") == "true"
        if (rest) {
            builder.append("vararg ")
        }
        builder.appendName(element).append(": ")
        val enclose = optional && typeName.indexOf('(') != -1
        if (enclose) {
            builder.append('(')
        }
        builder.append(typeName)
        if (optional) {
            if (enclose) {
                builder.append(')')
            }
            builder.append("?")
            if (!rest) {
                builder.append(" = null")
            }
        }
        val default = element.attribute("default")
        if (default != null) {
            builder.append(" = ").append(default)
        }
    }

    private fun getName(element: Element): String {
        val name = element.getAttribute("name")!!
        return when (name) {
            "type", "object" -> "`$name`"
            else -> name
        }
    }

    private fun StringBuilder.appendName(element: Element): StringBuilder {
        append(getName(element))
        return this
    }

    private fun StringBuilder.appendType(element: Element, attributeName: String = "type"): StringBuilder {
        append(": ").append(getType(element, attributeName))
        return this
    }

    private fun getType(element: Element, attributeName: String = "type"): String  = getType(element.attribute(attributeName))

    private fun getType(typeName: String?): String {
        return when (typeName) {
            "AbstractView" -> "html.AbstractView"
            "Range" -> "org.w3c.dom.Range"
            "long" -> "Long"
            "int" -> "Int"
            "byte" -> "Byte"
            "float" -> "Float"
            "double" -> "Double"
            "window" -> "Window"

            "Error" -> "java.lang.Exception"
            "void", null -> "Unit"
            "Function" -> "()->Unit"
            "Function?" -> "(()->Unit)?"
            "Array" -> "Array<Any>"
            "Object", "*" -> "Any"
            "Object?" -> "Any?"
            "\$__Type__$" -> currentClassName!!
            else -> {
                if (typeName.endsWith("[]")) {
                    "Array<${getType(typeName.substring(0, typeName.length - 2))}>"
                }
                else {
                    typeName
                }
            }
        }
    }
}