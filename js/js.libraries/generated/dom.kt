//
// NOTE THIS FILE IS AUTO-GENERATED by the GenerateJavaScriptStubs.kt
//

package org.w3c.dom

public native trait DOMImplementationRegistry {
	public fun getDOMImplementation(features: String): Unit
	public fun getDOMImplementationList(features: String): Unit
}

public native trait DOMException {
	public var code: Number
}

public native trait DOMStringList {
	public val length: Number

	public fun item(index: Number): String
	public fun contains(str: String): Boolean
}

public native trait NameList {
	public val length: Number

	public fun getName(index: Number): String
	public fun getNamespaceURI(index: Number): String
	public fun contains(str: String): Boolean
	public fun containsNS(namespaceURI: String, name: String): Boolean
}

public native trait DOMImplementationList {
	public val length: Number

	public fun item(index: Number): DOMImplementation
}

public native trait DOMImplementationSource {
	public fun getDOMImplementation(features: String): DOMImplementation
	public fun getDOMImplementationList(features: String): DOMImplementationList
}

public native trait DOMImplementation {
	public fun hasFeature(feature: String, version: String): Boolean
	public fun createDocumentType(qualifiedName: String, publicId: String, systemId: String): DocumentType
	public fun createDocument(namespaceURI: String?, qualifiedName: String?, doctype: DocumentType?): Document
	public fun getFeature(feature: String, version: String): Any
}

public native trait DocumentFragment : Node {
}

public native trait Document : Node {
	public val doctype: DocumentType
	public val implementation: DOMImplementation
	public val documentElement: Element
	public val inputEncoding: String
	public val xmlEncoding: String
	public var xmlStandalone: Boolean
	public var xmlVersion: String
	public var strictErrorChecking: Boolean
	public var documentURI: String
	public val domConfig: DOMConfiguration

	public fun createElement(tagName: String): Element
	public fun createDocumentFragment(): DocumentFragment
	public fun createTextNode(data: String): Text
	public fun createComment(data: String): Comment
	public fun createCDATASection(data: String): CDATASection
	public fun createProcessingInstruction(target: String, data: String): ProcessingInstruction
	public fun createAttribute(name: String): Attr
	public fun createEntityReference(name: String): EntityReference
	public fun getElementsByTagName(tagname: String): NodeList
	public fun importNode(importedNode: Node, deep: Boolean): Node
	public fun createElementNS(namespaceURI: String, qualifiedName: String): Element
	public fun createAttributeNS(namespaceURI: String, qualifiedName: String): Attr
	public fun getElementsByTagNameNS(namespaceURI: String, localName: String): NodeList
	public fun getElementById(elementId: String): Element
	public fun adoptNode(source: Node): Node
	public fun normalizeDocument(): Unit
	public fun renameNode(n: Node, namespaceURI: String, qualifiedName: String): Node
	public fun nodeFromID(idString: String? = null): Node
}

public native trait IXMLDOMParseError {
	public var reason: String
	public var errorCode: Number
}

public native trait Node {
	public native class object {
		public val ELEMENT_NODE: Number = 1
		public val ATTRIBUTE_NODE: Number = 2
		public val TEXT_NODE: Number = 3
		public val CDATA_SECTION_NODE: Number = 4
		public val ENTITY_SECTION_NODE: Number = 5
		public val ENTITY_NODE: Number = 6
		public val PROCESSING_INSTRUCTION_NODE: Number = 7
		public val COMMENT_NODE: Number = 8
		public val DOCUMENT_NODE: Number = 9
		public val DOCUMENT_TYPE_NODE: Number = 10
		public val DOCUMENT_FRAGMENT_NODE: Number = 11
		public val NOTATION_NODE: Number = 12
	}

	public val nodeName: String
	public var nodeValue: String
	public val nodeType: Number
	public val parentNode: Node
	public val childNodes: NodeList
	public val firstChild: Node
	public val lastChild: Node
	public val previousSibling: Node
	public val nextSibling: Node
	public val attributes: NamedNodeMap
	public val ownerDocument: Document
	public val namespaceURI: String
	public var prefix: String
	public val localName: String
	public val baseURI: String
	public var textContent: String
	public val xml: String

	public fun insertBefore(newChild: Node, refChild: Node): Node
	public fun replaceChild(newChild: Node, refChild: Node): Node
	public fun removeChild(oldChild: Node): Node
	public fun appendChild(newChild: Node): Node
	public fun hasChildNodes(): Boolean
	public fun cloneNode(deep: Boolean): Node
	public fun normalize(): Unit
	public fun isSupported(feature: String, version: String): Boolean
	public fun hasAttributes(): Boolean
	public fun compareDocumentPosition(other: Node): Node
	public fun isSameNode(other: Node): Boolean
	public fun lookupPrefix(namespaceURI: String): String
	public fun isDefaultNamespace(namespaceURI: String): String
	public fun lookupNamespaceURI(prefix: String): String
	public fun isEqualNode(arg: Node): Boolean
	public fun getFeature(feature: String, version: String): Any
	public fun setUserData(key: String, data: Any, handler: UserDataHandler): Unit
	public fun getUserData(key: String): Unit
}

public native trait NodeList {
	public val length: Int

	public fun item(index: Int): Node
}

public native trait NamedNodeMap {
	public val length: Int

	public fun getNamedItem(name: String): Node
	public fun setNamedItem(arg: Node): Node
	public fun removeNamedItem(name: String): Node
	public fun item(index: Number): Node
	public fun getNamedItemNS(namespaceURI: String, localName: String): Node
	public fun setNamedItemNS(arg: Node): Node
	public fun removeNamedItemNS(namespaceURI: String, localName: String): Node
}

public native trait CharacterData : Node {
	public var data: String
	public val length: Number

	public fun substringData(offset: Number, count: Number): String
	public fun appendData(arg: String): Unit
	public fun insertData(offset: Number, arg: String): Unit
	public fun deleteData(offset: Number, count: Number): Unit
	public fun replaceData(offset: Number, count: Number, arg: String): Unit
}

public native trait Attr : Node {
	public val name: String
	public val specified: Boolean
	public var value: String
	public val ownerElement: Element
	public val schemaTypeInfo: TypeInfo
	public val isId: Boolean
}

public native trait Element : Node {
	public val tagName: String
	public val schemaTypeInfo: TypeInfo

	public fun getAttribute(name: String): String
	public fun setAttribute(name: String, value: String): Unit
	public fun removeAttribute(name: String): Unit
	public fun getAttributeNode(name: String): Attr
	public fun setAttributeNode(newAttr: Attr): Attr
	public fun removeAttributeNode(oldAttr: Attr): Attr
	public fun getElementsByTagName(name: String): NodeList
	public fun getAttributeNS(namespaceURI: String, localName: String): String
	public fun setAttributeNS(namespaceURI: String, qualifiedName: String, value: String): Unit
	public fun removeAttributeNS(namespaceURI: String, localName: String): Unit
	public fun getAttributeNodeNS(namespaceURI: String, localName: String): Unit
	public fun setAttributeNodeNS(newAttr: Attr): Unit
	public fun getElementsByTagNameNS(namespaceURI: String, localName: String): NodeList
	public fun hasAttribute(name: String): Boolean
	public fun hasAttributeNS(namespaceURI: String, localName: String): Boolean
	public fun setIdAttribute(name: String, isId: Boolean): Unit
	public fun setIdAttributeNS(namespaceURI: String, localName: String, isId: Boolean): Unit
	public fun setIdAttributeNode(idAttr: Attr, isId: Boolean): Unit

	public val firstElementChild: Element
	public val lastElementChild: Element
	public val previousElementSibling: Element
	public val nextElementSibling: Element
	public val childElementCount: Number
}

public native trait Text : CharacterData {
	public val isElementContentWhitespace: Boolean
	public val wholeText: String

	public fun splitText(offset: Number): Text
	public fun replaceWholeText(content: String): Text
}

public native trait Comment : CharacterData {
}

public native trait TypeInfo {
	public val typeName: String
	public val typeNamespace: String

	public fun isDerivedFrom(typeNamespaceArg: String, typeNameArg: String, derivationMethod:  Number): Boolean
}

public native trait UserDataHandler {
	public native class object {
		public val NODE_CLONED: Int = 1
		public val NODE_IMPORTED: Int = 2
		public val NODE_DELETED: Int = 3
		public val NODE_RENAMED: Int = 4
		public val NODE_ADOPTED: Int = 5
	}

	public fun handle(operation: Int, key: String, data: Any, src: Node, dst: Node): Unit
}

public native trait DOMError {
	public var severity: Number
	public var message: String
	public var `type`: String
	public var relatedException: Any
	public var relatedData: Any
	public var location: DOMLocator
}

public native trait DOMErrorHandler {
	public fun handler(error: DOMError): Boolean
}

public native trait DOMLocator {
	public var lineNumber: Number
	public var columnNumber: Number
	public var byteOffset: Number
	public var utf16Offset: Number
	public var relatedNode: Node
	public var uri: String
}

public native trait DOMConfiguration {
	public var parameterNames: DOMStringList

	public fun setParameter(name: String, value: Any): Unit
	public fun getParameter(name: String): Unit
	public fun canSetParameter(name: String, value: Any): Boolean
}

public native trait CDATASection : Text {
}

public native trait DocumentType : Node {
	public val name: String
	public val entities: NamedNodeMap
	public val notations: NamedNodeMap
	public val publicId: String
	public val systemId: String
	public val internalSubset: String
}

public native trait Notation : Node {
	public val publicId: String
	public val systemId: String
}

public native trait Entity : Node {
	public val publicId: String
	public val systemId: String
	public val notationName: String
	public val inputEncoding: String
	public val xmlEncoding: String
	public val xmlVersion: String
}

public native trait EntityReference : Node {
}

public native trait ProcessingInstruction : Node {
	public val target: String
	public var data: String
}

public native trait Event {
	public native class object {
		public val CAPTURING_PHASE: Int = 1
		public val AT_TARGET: Int = 2
		public val BUBBLING_PHASE: Int = 2
	}

	public val `type`: String
	public val target: EventTarget
	public val currentTarget: EventTarget
	public val eventPhase: Int
	public val bubbles: Boolean
	public val cancelable: Boolean
	public val timeStamp: Date
	public val namespaceURI: String

	public fun stopPropagation(): Unit
	public fun preventDefault(): Unit
	public fun initEvent(eventTypeArg: String, canBubbleArg: Boolean, cancelableArg: Boolean): Unit
	public fun isCustom(): Boolean
	public fun stopImmediatePropagation(): Unit
	public fun isDefaultPrevented(): Boolean
	public fun initEventNS(namespaceURIArg: String, eventTypeArg: String, canBubbleArg: Boolean, cancelableArg: Boolean): Unit
}

public native trait EventTarget {
	public fun addEventListener(`type`: String, listener: EventListener, useCapture: Boolean? = null): Unit
	public fun addEventListener(`type`: String, listener: ()->Unit, useCapture: Boolean? = null): Unit
	public fun removeEventListener(`type`: String, listener: EventListener, useCapture: Boolean? = null): Unit
	public fun removeEventListener(`type`: String, listener: ()->Unit, useCapture: Boolean? = null): Unit
	public fun dispatchEvent(event: Event): Boolean
	public fun addEventListenerNS(namespaceURI: String, `type`: String, listener: EventListener, useCapture: Boolean? = null, evtGroup: Any? = null): Unit
	public fun removeEventListenerNS(namespaceURI: String, `type`: String, listener: EventListener, useCapture: Boolean? = null): Unit
	public fun willTriggerNS(namespaceURI: String, `type`: String): Boolean
	public fun hasEventListenerNS(namespaceURI: String, `type`: String): Boolean
}

public native trait EventListener {
	public fun handleEvent(event: Event): Unit
}

public native trait EventException {
	public var code: Number
}

public native trait DocumentEvent {
	public fun createEvent(eventType: String): Event
	public fun canDispatch(namespaceURI: String, `type`: String): String
}

public native trait CustomEvent : Event {
	public fun setDispatchState(target: EventTarget, phase: Number): Unit
	public fun isPropagationStopped(): Boolean
	public fun isImmediatePropagationStopped(): Boolean
}

public native trait UIEvent : Event {
	public val view: html.AbstractView
	public val detail: Long

	public fun initUIEvent(typeArg: String, canBubbleArg: Boolean, cancelableArg: Boolean, viewArg: html.AbstractView, detailArg: Number): Unit
	public fun initUIEventNS(namespaceURI: String, typeArg: String, canBubbleArg: Boolean, cancelableArg: Boolean, viewArg: html.AbstractView, detailArg: Number): Unit
}

public native trait TextEvent : UIEvent {
	public val data: String

	public fun initTextEvent(typeArg: String, canBubbleArg: Boolean, cancelableArg: Boolean, viewArg: html.AbstractView, dataArg: Number): Unit
	public fun initTextEventNS(namespaceURI: String, typeArg: String, canBubbleArg: Boolean, cancelableArg: Boolean, viewArg: html.AbstractView, dataArg: Number): Unit
}

public native trait MouseEvent : UIEvent {
	public val screenX: Long
	public val screenY: Long
	public val clientX: Long
	public val clientY: Long
	public val ctrlKey: Boolean
	public val shiftKey: Boolean
	public val altKey: Boolean
	public val metaKey: Boolean
	public val button: Number
	public val relatedTarget: EventTarget

	public fun getModifierState(keyIdentifierArg: String): Boolean
	public fun initMouseEvent(typeArg: String, canBubbleArg: Boolean, cancelableArg: Boolean, viewArg: html.AbstractView, detailArg: Long, screenXArg: Long, screenYArg: Long, clientXArg: Long, clientYArg: Long, ctrlKeyArg: Boolean, altKeyArg: Boolean, shiftKeyArg: Boolean, metaKeyArg: Boolean, buttonArg: Int, relatedTargetArg: EventTarget): Unit
	public fun initMouseEventNS(namespaceURI: String, typeArg: String, canBubbleArg: Boolean, cancelableArg: Boolean, viewArg: html.AbstractView, detailArg: Number, screenXArg: Number, screenYArg: Number, clientXArg: Number, clientYArg: Number, ctrlKeyArg: Boolean, altKeyArg: Boolean, shiftKeyArg: Boolean, metaKeyArg: Boolean, buttonArg: Number, relatedTargetArg: EventTarget): Unit
}

public native trait KeyboardEvent : UIEvent {
	public val keyIdentifier: String
	public val keyLocation: Number
	public val ctrlKey: Boolean
	public val shiftKey: Boolean
	public val altKey: Boolean
	public val metaKey: Boolean

	public fun getModifierState(keyIdentifierArg: String): Boolean
	public fun initKeyboardEvent(typeArg: String, canBubbleArg: Boolean, cancelableArg: Boolean, viewArg: html.AbstractView, keyIdentifierArg: String, keyLocationArg: Number, modifiersList: String): Unit
	public fun initKeyboardEventNS(namespaceURI: String, typeArg: String, canBubbleArg: Boolean, cancelableArg: Boolean, viewArg: html.AbstractView, keyIdentifierArg: String, keyLocationArg: Number, modifiersList: String): Unit
}

public native trait MutationEvent : UIEvent {
	public native class object {
		public val MODIFICATION: Int = 1
		public val ADDITION: Int = 2
		public val REMOVAL: Int = 3
	}

	public val relatedNode: Node
	public val prevValue: String
	public val newValue: String
	public val attrName: String
	public val attrChange: Number

	public fun initMutationEvent(typeArg: String, canBubbleArg: Boolean, cancelableArg: Boolean, relatedNodeArg: Node, prevValueArg: String, newValueArg: String, attrNameArg: String, attrChangeArg: Number): Unit
	public fun initMutationEventNS(namespaceURI: String, typeArg: String, canBubbleArg: Boolean, cancelableArg: Boolean, relatedNodeArg: Node, prevValueArg: String, newValueArg: String, attrNameArg: String, attrChangeArg: Number): Unit
}

public native trait MutationNameEvent : MutationEvent {
	public val prevNamespaceURI: String
	public val prevNodeName: String

	public fun initMutationNameEvent(typeArg: String, canBubbleArg: Boolean, cancelableArg: Boolean, relatedNodeArg: Node, prevNamespaceURIArg: String, prevNodeNameArg: String): Unit
	public fun initMutationNameEventNS(namespaceURI: String, typeArg: String, canBubbleArg: Boolean, cancelableArg: Boolean, relatedNodeArg: Node, prevNamespaceURIArg: String, prevNodeNameArg: String): Unit
}

public native trait NodeIterator {
	public val root: Node
	public val whatToShow: Number
	public val filter: NodeFilter
	public val expandEntityReferences: Boolean

	public fun nextNode(): Node
	public fun previousNode(): Node
	public fun detach(): Unit
}

public native trait NodeFilter {
	public fun NodeFilter(param: Node): Number
}

public native trait TreeWalker {
	public fun parentNode(): Node
	public fun firstChild(): Node
	public fun lastChild(): Node
	public fun previousSibling(): Node
	public fun nextSibling(): Node
	public fun previousNode(): Node
	public fun nextNode(): Node
}

public native trait DocumentTraversal {
	public fun createNodeIterator(root: Node, whatToShow: Number, filter: NodeFilter, entityReferenceExpansion: Boolean): NodeIterator
	public fun createTreeWalker(root: Node, whatToShow: Number, filter: NodeFilter, entityReferenceExpansion: Boolean): TreeWalker
}

public native trait Range {
	public val startContainer: Node
	public val startOffset: Number
	public val endContainer: Node
	public val endOffset: Number
	public val collapsed: Boolean
	public val commonAncestorContainer: Node

	public fun setStart(refNode: Node, offset: Number): Unit
	public fun setEnd(refNode: Node, offset: Number): Unit
	public fun setStartBefore(refNode: Node): Unit
	public fun setStartAfter(refNode: Node): Unit
	public fun setEndBefore(refNode: Node): Unit
	public fun setEndAfter(refNode: Node): Unit
	public fun collapse(toStart: Boolean): Unit
	public fun selectNode(refNode: Node): Unit
	public fun selectNodeContents(refNode: Node): Unit
	public fun compareBoundaryPoints(how: Number, sourceRange: org.w3c.dom.Range): Number
	public fun deleteContents(): Unit
	public fun extractContents(): DocumentFragment
	public fun cloneContents(): DocumentFragment
	public fun insertNode(newNode: Node): Unit
	public fun surroundContents(newParent: Node): Unit
	public fun cloneRange(): org.w3c.dom.Range
	public fun toString(): String
	public fun detach(): Unit
	public fun createContextualFragment(tagString: String): Unit
}

public native trait DocumentRange {
	public fun createRange(): org.w3c.dom.Range
}

public native trait RangeException {
	public var code: Number
}