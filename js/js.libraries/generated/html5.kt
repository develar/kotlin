// NOTE THIS FILE IS AUTO-GENERATED by the JavaScriptStubGenerator

package html

import org.w3c.dom.*

public trait Image : HTMLImageElement {
	public var constructor: Unit
}

public trait Navigator {
	public var userAgent: String
	public var product: String
	public var appVersion: String
	public var appName: String
	public var appCodeName: String
	public var language: String
	public var mimeTypes: Array<Any>
	public var platform: String
	public var plugins: Array<Any>
	public var onLine: Boolean
	public var cookieEnabled: Boolean

	public fun taintEnabled(): Boolean
	public fun javaEnabled(): Boolean
	public fun preference(prefName: String, prefValue: String? = null): String

	public val geolocation: Geolocation
}

public trait Screen {
	public var width: Number
	public var height: Number
	public var availHeight: Number
	public var availWidth: Number
	public var pixelDepth: Number
	public var colorDepth: Number
}

public trait Option {
	public var defaultSelected: Boolean
	public var selected: Boolean
	public var text: String
	public var value: String
}

public trait Location {
	public var href: String
	public var hash: String
	public var port: String
	public var host: String
	public var hostname: String
	public var pathname: String
	public var protocol: String
	public var search: String
	public var target: String

	public fun reload(forceget: Boolean? = null): Unit
	public fun replace(url: String): Unit

	public fun assign(url: String? = null): Unit
	public fun resolveURL(url: String? = null): String
}

public trait XSLTProcessor {
	public var constructor: Unit

	public fun importStylesheet(domNode: Node): Unit
	public fun transformToDocument(domNode: Node): Document
	public fun transformToFragment(domToBeTransformed: Node, ownerDocument: Document): DocumentFragment
}

public trait DOMParser {
	public var constructor: Unit

	public fun parseFromString(stringToParse: String, contentType: String): Document
}

public trait XMLSerializer {
	public var constructor: Unit

	public fun serializeToStream(domNode: Document, stream: Any, encoding: String): Unit
	public fun serializeToString(domNode: Document): String
}

public trait Event {
	public var data: Array<Any>
	public var height: Number
	public var screenX: Number
	public var clientX: Number
	public var layerX: Number
	public var pageX: Number
	public var screenY: Number
	public var clientY: Number
	public var layerY: Number
	public var pageY: Number
	public var width: Number
	public var modifiers: Number
	public var keyCode: Number
	public var `type`: String
	public var which: Any
	public var altKey: Boolean
	public var ctrlKey: Boolean
	public var shiftKey: Boolean
	public var button: Boolean
	public var charCode: String
}

public trait Selection {
	public var anchorNode: Node
	public var anchorOffset: Number
	public var focusNode: Node
	public var focusOffset: Number
	public var isCollapsed: Boolean
	public var rangeCount: Number

	public fun getRangeAt(index: Number): org.w3c.dom.Range
	public fun collapse(parentNode: Node, offset: Number): Unit
	public fun extend(parentNode: Node, offset: Number): Unit
	public fun collapseToStart(): Unit
	public fun collapseToEnd(): Unit
	public fun selectAllChildren(parentNode: Node): Unit
	public fun addRange(range: org.w3c.dom.Range): Unit
	public fun removeRange(range: org.w3c.dom.Range): Unit
	public fun removeAllRanges(): Unit
	public fun containsNode(node: Node, partlyContained: Boolean): Boolean
}

public trait TextRange {
	public var htmlText: String
	public var text: String
	public var boundingWidth: Number
	public var boundingHeight: Number
	public var boundingLeft: Number
	public var offsetLeft: Number
	public var boundingTop: Number
	public var offsetTop: Number

	public fun getBookmark(): String
	public fun moveToBookmark(sBookmark: String? = null): Boolean
	public fun collapse(start: Boolean? = null): Unit
	public fun expand(unit: String? = null): Unit
	public fun duplicate(): TextRange
	public fun select(): Unit
	public fun parentElement(): Node
	public fun inRange(other: TextRange): Boolean
	public fun isEqual(other: TextRange): Boolean
	public fun scrollIntoView(start: Boolean? = null): Unit
	public fun setEndPoint(`type`: String, range: TextRange): Unit
	public fun compareEndPoint(`type`: String, range: TextRange): Unit
	public fun move(unit: String, count: Number? = null): Unit
	public fun moveStart(unit: String, count: Number? = null): Unit
	public fun moveEnd(unit: String, count: Number? = null): Unit
	public fun pasteHTML(htmlText: String): Unit
	public fun moveToElementText(element: HTMLElement? = null): Unit
	public fun compareEndPoints(sType: String? = null, oRange: TextRange? = null): Number
}

public trait CssRule {
	public var selectorText: String
}

public trait Stylesheet {
	public var cssRules: Array<CssRule>

	public fun insertRule(ruleText: String, index: Number): Unit
	public fun deleteRule(index: Number): Unit
}

public trait MozillaSideBar {
	public fun addPanel(title: String, url: String, param3: String): Unit
}

public trait IEExternal {
	public fun AddFavorite(title: String, url: String? = null): Unit
}

public trait History {
	public fun back(): Unit
	public fun forward(): Unit
	public fun go(count: Number): Unit

	public val length: Int
	public val state: Any

	public fun pushState(data: Any? = null, title: String? = null, url: String? = null): Unit
	public fun replaceState(data: Any? = null, title: String? = null, url: String? = null): Unit
}

public trait Console {
	public fun info(vararg message: Any): Unit
	public fun warn(vararg message: Any): Unit
	public fun error(vararg message: Any): Unit
	public fun log(vararg message: Any): Unit
	public fun dir(vararg message: Any): Unit
	public fun group(): Unit
	public fun groupCollapsed(): Unit
	public fun groupEnd(): Unit
	public fun trace(): Unit
	public fun time(timerName: String): Unit
	public fun timeEnd(timerName: String): Unit
	public fun time(): Unit
}

public val console: Console

public trait Window {

	public val document: HTMLDocument
	public val event: Event
	public val navigator: Navigator
	public val screen: Screen
	public var location: Any
	public var console: Console
	public var frameElement: Any
	public var opener: Window
	public var window: Window
	public var parent: Window
	public var top: Window
	public var self: Any
	public var frames: Array<Any>
	public var innerHeight: Number
	public var innerWidth: Number
	public var outerHeight: Number
	public var outerWidth: Number
	public var scrollX: Number
	public var scrollY: Number
	public var pageXOffset: Number
	public var pageYOffset: Number
	public var scrollMaxX: Number
	public var scrollMaxY: Number
	public var status: String
	public var defaultStatus: String
	public var toolbar: Any
	public var menubar: Any
	public var scrollbars: Any
	public var directories: Any
	public var history: History
	public var sidebar: MozillaSideBar
	public var opera: Boolean
	public val clipboardData: ClipboardData
	public var onload: ()->Unit
	public var onunload: ()->Unit

	public fun getSelection(): Selection
	public fun open(url: String? = null, windowName: String? = null, windowFeatures: String? = null, replace: Boolean? = null): Window
	public fun close(): Unit
	public fun print(): Unit
	public fun alert(message: String): Unit
	public fun alert(message: Any): Unit
	public fun atob(encodedData: String): String
	public fun btoa(decodedData: String): String
	public fun confirm(message: String): Unit
	public fun prompt(message: String, defaultValue: String? = null): Unit
	public fun clearInterval(intervalId: Long): Unit
	public fun clearTimeout(intervalId: Long): Unit
	public fun setInterval(code: String, delay: Int): Long
	public fun setInterval(code: ()->Unit, delay: Int): Long
	public fun setTimeout(code: String, delay: Int): Long
	public fun setTimeout(code: ()->Unit, delay: Int): Long
	public fun scrollTo(x: Number, y: Number): Unit
	public fun scrollBy(xDelta: Number, yDelta: Number): Unit
	public fun moveTo(x: Number, y: Number): Unit
	public fun moveBy(xDelta: Number, yDelta: Number): Unit
	public fun resizeTo(width: Number, height: Number): Unit
	public fun resizeBy(widthDelta: Number, heightDelta: Number): Unit
	public fun getComputedStyle(element: Element, pseudoElt: String): CSSStyleDeclaration
	public fun addEventListener(`type`: String, listener: ()->Unit, useCapture: Boolean? = null): Unit
	public fun removeEventListener(`type`: String, listener: ()->Unit, useCapture: Boolean? = null): Unit

	public fun ActiveXObject(sName: String? = null): XMLHttpRequest

	public val localStorage: Storage
	public val sessionStorage: Storage

	public fun webkitRequestAnimationFrame(callback: ()->Unit, element: Element): Number
	public fun webkitCancelRequestAnimationFrame(callback: ()->Unit): Unit
	public fun msRequestAnimationFrame(callback: ()->Unit): Number
	public fun msCancelRequestAnimationFrame(callback: ()->Unit): Unit
	public fun oRequestAnimationFrame(callback: ()->Unit): Number
	public fun oCancelRequestAnimationFrame(callback: ()->Unit): Unit
	public fun mozRequestAnimationFrame(callback: ()->Unit): Number
	public fun mozCancelRequestAnimationFrame(callback: ()->Unit): Unit
	public fun requestAnimationFrame(callback: ()->Unit, element: Element): Number
	public fun cancelRequestAnimationFrame(callback: ()->Unit): Unit
	public fun importScripts(vararg urls: String?): Unit
	public fun openDatabase(name: String, version: String, displayName: String, estimatedSize: Number, creationCallback: DatabaseCallback? = null): Database
	public fun openDatabase(name: String, version: String, displayName: String, estimatedSize: Number, creationCallback: ()->Unit): Database
	public fun openDatabaseSync(name: String, version: String, displayName: String, estimatedSize: Number, creationCallback: DatabaseCallback? = null): Database
	public fun openDatabaseSync(name: String, version: String, displayName: String, estimatedSize: Number, creationCallback: ()->Unit): Database
}

public val window: Window

public trait ClipboardData {
	public fun setData(sDataFormat: String, sData: String): Boolean
	public fun getData(sDataFormat: String): String
	public fun clearData(sDataFormat: String? = null): Boolean
}

public trait HTMLCollection {
	public val length: Number

	public fun item(index: Number): Node
	public fun namedItem(name: String): Node
}

public trait HTMLOptionsCollection {
	public val length: Number

	public fun item(index: Int): Node
	public fun namedItem(name: String): Node
}

public trait HTMLDocument : Document {
	public var title: String
	public val referrer: String
	public val domain: String
	public val URL: String
	public var body: HTMLElement
	public val images: HTMLCollection
	public val applets: HTMLCollection
	public val links: HTMLCollection
	public val forms: HTMLCollection
	public val anchors: HTMLCollection
	public var cookie: HTMLCollection
	public val styleSheets: Array<Stylesheet>
	public var defaultView: DocumentView
	public var compatMode: String
	public var commandDispatcher: CommandDispatcher
	public var onload: ()->Unit
	public var onunload: ()->Unit

	public fun open(): Unit
	public fun close(): Unit
	public fun write(text: String): Unit
	public fun writeln(text: String): Unit
	public fun getElementsByName(elementName: String): NodeList
	public fun getElementsByClassName(className: String): NodeList
	public fun querySelectorAll(selector: String): NodeList
	public fun querySelector(selector: String): Node
	public fun getAnonymousNodes(node: HTMLElement): Array<Node>
	public fun getAnonymousElementByAttribute(node: HTMLElement, attrName: String, attrValue: String): NodeList
}

public val document: HTMLDocument

public trait CommandDispatcher {
	public var focusedElement: HTMLElement
}

public trait AbstractView {
}

public trait DocumentView : html.AbstractView {
	public fun getComputedStyle(element: Node, `type`: String): CssStyle
}

public trait CssStyle {
	public fun getPropertyValue(propertyName: String): String
}

public trait HTMLElement : Element {
	public var outerHTML: String
	public var id: String
	public var title: String
	public var lang: String
	public var dir: String
	public var className: String
	public var style: CSSStyleDeclaration
	public var clientWidth: Int
	public var clientHeight: Int
	public var clientTop: Int
	public var clientLeft: Int
	public var innerHTML: String
	public var offsetWidth: Int
	public var offsetHeight: Int
	public var offsetTop: Int
	public var offsetLeft: Int
	public var offsetParent: HTMLElement
	public var scrollWidth: Int
	public var scrollHeight: Int
	public var scrollTop: Int
	public var scrollLeft: Int
	public var stylesheet: Stylesheet
	public var onblur: ()->Unit
	public var onclick: ()->Any
	public var ondblclick: ()->Unit
	public var onfocus: ()->Unit
	public var onkeydown: ()->Unit
	public var onkeyup: ()->Unit
	public var onmouseup: ()->Unit
	public var onmousedown: ()->Unit
	public var onmouseout: ()->Unit
	public var onmouseover: ()->Unit
	public var onmousemove: ()->Unit
	public var onresize: ()->Unit
	public var boxObject: HTMLElement

	public fun showPopup(): Unit
	public fun hidePopup(): Unit
}

public trait ClientRect {
	public val bottom: Number
	public val height: Number
	public val left: Number
	public val right: Number
	public val top: Number
	public val width: Number
}

public trait CSSStyleDeclaration {
	public var cssText: String
	public var length: Int
	public var parentRule: CSSRule

	public fun getPropertyCSSValue(propertyName: String): CSSValue
	public fun getPropertyPriority(propertyName: String): String
	public fun getPropertyValue(propertyName: String): String
	public fun item(index: Number): String
	public fun removeProperty(propertyName: String): String
	public fun setProperty(propertyName: String, value: String, priority: String): Unit
}

public trait CSSRule {
	public class object {
		public val STYLE_RULE: Int = 1
		public val MEDIA_RULE: Int = 4
		public val FONT_FACE_RULE: Int = 5
		public val PAGE_RULE: Int = 6
		public val IMPORT_RULE: Int = 3
		public val CHARSET_RULE: Int = 2
		public val UNKNOWN_RULE: Int = 0
		public val KEYFRAMES_RULE: Int = 7
		public val KEYFRAME_RULE: Int = 8
		public val NAMESPACE_RULE: Int = 10
		public val COUNTER_STYLE_RULE: Int = 11
		public val SUPPORTS_RULE: Int = 12
		public val DOCUMENT_RULE: Int = 13
		public val FONT_FEATURE_VALUES_RULE: Int = 14
		public val VIEWPORT_RULE: Int = 15
		public val REGION_STYLE_RULE: Int = 16
	}
	public var cssText: String
	public var parentRule: CSSRule
	public var parentStyleSheet: CSSStyleSheet
	public var `type`: Int
}

public trait CSSValue {
	public class object {
		public val CSS_INHERIT: Int = 0
		public val CSS_PRIMITIVE_VALUE: Int = 1
		public val CSS_VALUE_LIST: Int = 2
		public val CSS_CUSTOM: Int = 3
	}
	public var cssText: String
	public var cssValueType: Int
}

public trait CSSStyleSheet {
	public val cssRules: Array<CSSRule>
	public val ownerRule: CSSImportRule?

	public fun insertRule(rule: String, index: Int): Unit
	public fun deleteRule(index: Int): Unit
}

public trait CSSImportRule {
	public var href: String
	public var media: Any
	public var styleSheet: CSSStyleSheet
}

public trait IEElementStyle : CSSStyleDeclaration {
	public var hasLayout: Boolean
}

public trait HTMLHtmlElement : HTMLElement {
	public var version: String
}

public trait HTMLHeadElement : HTMLElement {
	public var profile: String
}

public trait HTMLLinkElement : HTMLElement {
	public var disabled: Boolean
	public var charset: String
	public var href: String
	public var hreflang: String
	public var media: String
	public var rel: String
	public var rev: String
	public var target: String
	public var `type`: String
}

public trait HTMLTitleElement : HTMLElement {
	public var text: String
}

public trait HTMLMetaElement : HTMLElement {
	public var content: String
	public var httpEquiv: String
	public var name: String
	public var scheme: String
}

public trait HTMLBaseElement : HTMLElement {
	public var href: String
	public var target: String
}

public trait HTMLIsIndexElement : HTMLElement {
	public val form: HTMLFormElement
	public var prompt: String
}

public trait HTMLStyleElement : HTMLElement {
	public var disabled: Boolean
	public var media: String
	public var `type`: String
}

public trait HTMLBodyElement : HTMLElement {
	public var aLink: String
	public var background: String
	public var bgColor: String
	public var link: String
	public var text: String
	public var vLink: String
	public var onload: ()->Unit
	public var onunload: ()->Unit
}

public trait HTMLFormElement : HTMLElement {
	public val elements: HTMLCollection
	public val length: Number
	public var name: String
	public var acceptCharset: String
	public var action: String
	public var enctype: String
	public var method: String
	public var target: String
	public var autocomplete: String
	public var noValidate: Boolean

	public fun submit(): Unit
	public fun reset(): Unit
}

public trait HTMLSelectElement : HTMLElement {
	public val `type`: String
	public var selectedIndex: Number
	public var value: String
	public var length: Number
	public val form: HTMLFormElement
	public val options: HTMLOptionsCollection
	public var disabled: Boolean
	public var multiple: Boolean
	public var name: String
	public var size: Number
	public var tabIndex: Number

	public fun add(element: HTMLElement, before: HTMLElement): Unit
	public fun remove(index: Number): Unit
	public fun blur(): Unit
	public fun focus(): Unit

	public var autofocus: Boolean
	public var required: Boolean
	public var selectedOptions: HTMLCollection
	public var validationMessage: String
	public var validity: ValidityState
	public val willValidate: Boolean

	public fun checkValidity(): Boolean
	public fun item(index: Number): Element
	public fun namedItem(name: String): Element
	public fun setCustomValidity(error: String? = null): Unit
}

public trait HTMLOptGroupElement : HTMLElement {
	public var disabled: Boolean
	public var label: String
}

public trait HTMLOptionElement : HTMLElement {
	public val form: HTMLFormElement
	public var defaultSelected: Boolean
	public var text: String
	public var index: Number
	public var disabled: Boolean
	public var label: String
	public var selected: Boolean
	public var value: String
}

public trait HTMLInputElement : HTMLElement {
	public var defaultValue: String
	public var defaultChecked: Boolean
	public val form: HTMLFormElement
	public var accept: String
	public var accessKey: String
	public var align: String
	public var alt: String
	public var checked: Boolean
	public var disabled: Boolean
	public var maxLength: Number
	public var name: String
	public var readOnly: Boolean
	public var size: Number
	public var src: String
	public var tabIndex: Number
	public var `type`: String
	public var useMap: String
	public var value: String
	public var selectionStart: Number
	public var selectionEnd: Number

	public fun blur(): Unit
	public fun focus(): Unit
	public fun select(): Unit
	public fun click(): Unit
	public fun setSelectionRange(start: Number? = null, end: Number? = null): Unit

	public val files: FileList
}

public trait HTMLTextAreaElement : HTMLElement {
	public var defaultValue: String
	public val form: HTMLFormElement
	public var accessKey: String
	public var cols: Number
	public var disabled: Boolean
	public var name: String
	public var readOnly: Boolean
	public var rows: Number
	public var tabIndex: Number
	public var `type`: String
	public var value: String

	public fun blur(): Unit
	public fun focus(): Unit
	public fun select(): Unit
}

public trait HTMLButtonElement : HTMLElement {
	public val form: HTMLFormElement
	public var accessKey: String
	public var disabled: Boolean
	public var name: String
	public var tabIndex: Number
	public var `type`: String
	public var value: String
}

public trait HTMLLabelElement : HTMLElement {
	public val form: HTMLFormElement
	public var accessKey: String
	public var htmlFor: String
}

public trait HTMLFieldSetElement : HTMLElement {
	public val form: HTMLFormElement
}

public trait HTMLLegendElement : HTMLElement {
	public val form: HTMLFormElement
	public var accessKey: String
	public var align: String
}

public trait HTMLUListElement : HTMLElement {
	public var compact: Boolean
	public var `type`: String
}

public trait HTMLOListElement : HTMLElement {
	public var compact: Boolean
	public var start: Number
	public var `type`: String
}

public trait HTMLDListElement : HTMLElement {
	public var compact: Boolean
}

public trait HTMLDirectoryElement : HTMLElement {
	public var compact: Boolean
}

public trait HTMLMenuElement : HTMLElement {
	public var compact: Boolean
}

public trait HTMLLIElement : HTMLElement {
	public var `type`: String
	public var value: Number
}

public trait HTMLDivElement : HTMLElement {
	public var align: String
}

public trait HTMLParagraphElement : HTMLElement {
	public var align: String
}

public trait HTMLHeadingElement : HTMLElement {
	public var align: String
}

public trait HTMLQuoteElement : HTMLElement {
	public var cite: String
}

public trait HTMLPreElement : HTMLElement {
	public var width: Number
}

public trait HTMLBRElement : HTMLElement {
	public var clear: String
}

public trait HTMLBaseFontElement : HTMLElement {
	public var color: String
	public var face: String
	public var size: Number
}

public trait HTMLFontElement : HTMLElement {
	public var color: String
	public var face: String
	public var size: String
}

public trait HTMLHRElement : HTMLElement {
	public var align: String
	public var noShade: Boolean
	public var size: String
	public var width: String
}

public trait HTMLModElement : HTMLElement {
	public var cite: String
	public var dateTime: String
}

public trait HTMLAnchorElement : HTMLElement {
	public var accessKey: String
	public var charset: String
	public var coords: String
	public var href: String
	public var hreflang: String
	public var name: String
	public var rel: String
	public var rev: String
	public var shape: String
	public var tabIndex: Number
	public var target: String
	public var `type`: String

	public fun blur(): Unit
	public fun focus(): Unit
}

public trait HTMLImageElement : HTMLElement {
	public var name: String
	public var align: String
	public var alt: String
	public var border: String
	public var height: Number
	public var hspace: Number
	public var isMap: Boolean
	public var longDesc: String
	public var src: String
	public var useMap: String
	public var vspace: Number
	public var width: Number
	public var onload: ()->Unit
	public var onunload: ()->Unit

	public var crossOrigin: String
	public val complete: Boolean
	public val naturalHeight: Long
	public val naturalWidth: Long
}

public trait HTMLObjectElement : HTMLElement {
	public val form: HTMLFormElement
	public var code: String
	public var align: String
	public var archive: String
	public var border: String
	public var codeBase: String
	public var codeType: String
	public var data: String
	public var declare: Boolean
	public var height: String
	public var hspace: Number
	public var name: String
	public var standby: String
	public var tabIndex: Number
	public var `type`: String
	public var useMap: String
	public var vspace: Number
	public var width: String
	public val contentDocument: Document
}

public trait HTMLParamElement : HTMLElement {
	public var name: String
	public var `type`: String
	public var value: String
	public var valueType: String
}

public trait HTMLAppletElement : HTMLElement {
	public var align: String
	public var alt: String
	public var archive: String
	public var code: String
	public var codeBase: String
	public var height: String
	public var hspace: Number
	public var name: String
	public var `object`: String
	public var vspace: Number
	public var width: String
}

public trait HTMLMapElement : HTMLElement {
	public val areas: HTMLCollection
	public var name: String
}

public trait HTMLAreaElement : HTMLElement {
	public var accessKey: String
	public var alt: String
	public var coords: String
	public var href: String
	public var noHref: Boolean
	public var shape: String
	public var tabIndex: Number
	public var target: String
}

public trait HTMLScriptElement : HTMLElement {
	public var text: String
	public var htmlFor: String
	public var event: String
	public var charset: String
	public var defer: Boolean
	public var src: String
	public var `type`: String
}

public trait HTMLTableElement : HTMLElement {
	public var caption: HTMLTableCaptionElement
	public var tHead: HTMLTableSectionElement
	public var tFoot: HTMLTableSectionElement
	public val rows: HTMLCollection
	public val tBodies: HTMLCollection
	public var align: String
	public var bgColor: String
	public var border: String
	public var cellPadding: String
	public var cellSpacing: String
	public var frame: String
	public var rules: String
	public var summary: String
	public var width: String

	public fun createTHead(): HTMLElement
	public fun deleteTHead(): Unit
	public fun createTFoot(): HTMLElement
	public fun deleteTFoot(): Unit
	public fun createCaption(): HTMLElement
	public fun deleteCaption(): Unit
	public fun insertRow(index: Number): HTMLElement
	public fun deleteRow(index: Number): Unit
}

public trait HTMLTableCaptionElement : HTMLElement {
	public var align: String
}

public trait HTMLTableColElement : HTMLElement {
	public var align: String
	public var ch: String
	public var chOff: String
	public var span: Number
	public var vAlign: String
	public var width: String
}

public trait HTMLTableSectionElement : HTMLElement {
	public var align: String
	public var ch: String
	public var chOff: String
	public var vAlign: String
	public val rows: HTMLCollection

	public fun insertRow(index: Number): HTMLElement
	public fun deleteRow(index: Number): Unit
}

public trait HTMLTableRowElement : HTMLElement {
	public val rowIndex: Number
	public val sectionRowIndex: Number
	public val cells: HTMLCollection
	public var align: String
	public var bgColor: String
	public var ch: String
	public var chOff: String
	public var vAlign: String

	public fun insertCell(index: Number): HTMLElement
	public fun deleteCell(index: Number): Unit
}

public trait HTMLTableCellElement : HTMLElement {
	public val cellIndex: Number
	public var abbr: String
	public var align: String
	public var axis: String
	public var bgColor: String
	public var ch: String
	public var chOff: String
	public var colSpan: Number
	public var headers: String
	public var height: String
	public var noWrap: Boolean
	public var rowSpan: Number
	public var scope: String
	public var vAlign: String
	public var width: String
}

public trait HTMLFrameSetElement : HTMLElement {
	public var cols: String
	public var rows: String
}

public trait HTMLFrameElement : HTMLElement {
	public var frameBorder: String
	public var longDesc: String
	public var marginHeight: String
	public var marginWidth: String
	public var name: String
	public var noResize: Boolean
	public var scrolling: String
	public var src: String
	public val contentDocument: Document
}

public trait HTMLIFrameElement : HTMLElement {
	public var align: String
	public var frameBorder: String
	public var height: String
	public var longDesc: String
	public var marginHeight: String
	public var marginWidth: String
	public var name: String
	public var scrolling: String
	public var src: String
	public var width: String
	public val contentDocument: Document
	public val contentWindow: Window
}

public class XMLHttpRequest(vararg options: Any?) {
	public class object {
		public val UNSENT: Int = 0
		public val OPENED: Int = 1
		public val HEADERS_RECEIVED: Int = 2
		public val LOADING: Int = 3
		public val DONE: Int = 4
	}

	public var onreadystatechange: (()->Unit)?
	public var readyState: Int
	public val responseText: String?
	public val statusText: String
	public val status: Int
	public var responseXML: Document
	public var responseType: String
	public var response: Any?
	public var withCredentials: Boolean
	public val upload: XMLHttpRequestEventTarget

	public fun abort(): Unit
	public fun getAllResponseHeaders(): String?
	public fun getResponseHeader(headerName: String): String?
	public fun overrideMimeType(mimeType: String): Unit
	public fun open(method: String, url: String, async: Boolean? = null, user: String? = null, password: String? = null): Unit
	public fun send(data: String? = null): Unit
	public fun send(data: ArrayBuffer): Unit
	public fun send(data: Blob): Unit
	public fun send(data: Document): Unit
	public fun send(data: FormData): Unit
	public fun setRequestHeader(header: String, value: String): Unit
}

public trait XMLHttpRequestException : jet.Throwable {
	public class object {
		public val NETWORK_ERR: Int = 101
		public val ABORT_ERR: Int = 102
	}
	public val code: Int
}

public trait Blob {
	public val size: Long
	public val `type`: String

	public fun slice(start: Long? = null, end: Long? = null, contentType: String? = null): Blob
}

public trait FileList {
	public val length: Int

	public fun item(item: Int? = null): File
}

public trait File : Blob {
	public val name: String
	public val lastModifiedDate: Date
}

public trait FileReader : EventTarget {
	public class object {
		public val EMPTY: Int = 0
		public val LOADING: Int = 1
		public val DONE: Int = 2
	}
	public val readyState: Int
	public val result: Any
	public val error: java.lang.Exception
	public var onloadstart: ()->Unit
	public var onprogress: ()->Unit
	public var onload: ()->Unit
	public var onabort: ()->Unit
	public var onerror: ()->Unit
	public var onloadend: ()->Unit

	public fun readAsArrayBuffer(blob: Blob): Unit
	public fun readAsBinaryString(blob: Blob): Unit
	public fun readAsText(blob: Blob, encoding: String? = null): Unit
	public fun readAsDataURL(blob: Blob): Unit
	public fun abort(): Unit
}

public trait Node {
	public val dataset: DOMStringMap
	public val classList: DOMTokenList
}

public trait DOMStringMap {
}

public trait DOMTokenList {
	public val length: Number

	public fun contains(className: String): Boolean
	public fun add(className: String): Unit
	public fun remove(className: String): Unit
	public fun toggle(className: String): Unit
}

public trait DatabaseCallback {
	public fun handleEvent(database: Database): Unit
}

public trait Notification : EventTarget {
	public var ondisplay: ()->Unit
	public var onerror: ()->Unit
	public var onclose: ()->Unit

	public fun show(): Unit
	public fun cancel(): Unit
}

public trait HtmlElement {
}

public trait HTMLMediaElement : HTMLElement {
	public class object {
		public val HAVE_NOTHING: Number = 0
		public val HAVE_METADATA: Number = 1
		public val HAVE_CURRENT_DATA: Number = 2
		public val HAVE_FUTURE_DATA: Number = 3
		public val HAVE_ENOUGH_DATA: Number = 4
		public val NETWORK_EMPTY: Number = 0
		public val NETWORK_IDLE: Number = 1
		public val NETWORK_LOADING: Number = 2
		public val NETWORK_NO_SOURCE: Number = 3
	}
	public val error: MediaError
	public var src: String
	public val currentSrc: String
	public val networkState: Number
	public var preload: String
	public val buffered: TimeRanges
	public val readyState: Number
	public val seeking: Boolean
	public var currentTime: Number
	public val startTime: Number
	public val duration: Number
	public val paused: Boolean
	public var defaultPlaybackRate: Number
	public var playbackRate: Number
	public val played: TimeRanges
	public val seekable: TimeRanges
	public val ended: Boolean
	public var autoplay: Boolean
	public var loop: Boolean
	public var controls: Boolean
	public var volume: Number
	public var muted: Boolean
	public val tracks: Array<Any>

	public fun load(): Unit
	public fun canPlayType(`type`: String): String
	public fun play(): Unit
	public fun pause(): Unit
	public fun addTrack(label: String, kind: String, language: String): MutableTimedTrack
}

public trait MediaError {
	public class object {
		public val MEDIA_ERR_ABORTED: Int = 1
		public val MEDIA_ERR_NETWORK: Int = 2
		public val MEDIA_ERR_DECODE: Int = 3
		public val MEDIA_ERR_SRC_NOT_SUPPORTED: Int = 4
	}
	public val code: Int
}

public trait TimeRanges {
	public val length: Int

	public fun start(index: Int): Int
	public fun end(index: Int): Int
}

public trait TimedTrack {
	public class object {
		public val NONE: Int = 0
		public val LOADING: Int = 1
		public val LOADED: Int = 2
		public val ERROR: Int = 3
		public val OFF: Int = 0
		public val HIDDEN: Int = 1
		public val SHOWING: Int = 2
	}
	public val kind: String
	public val label: String
	public val language: String
	public val readyState: Int
	public val onload: ()->Unit
	public val onerror: ()->Unit
	public var mode: Int
	public val cues: TimedTrackCueList
	public val activeCues: TimedTrackCueList
	public val onentercue: ()->Unit
	public val onexitcue: ()->Unit
}

public trait MutableTimedTrack : TimedTrack {
	public fun addCue(cue: TimedTrackCue): Unit
	public fun removeCue(cue: TimedTrackCue): Unit
}

public trait TimedTrackCue {
	public val track: TimedTrack
	public val id: String
	public val startTime: Number
	public val endTime: Number
	public val pauseOnExit: Boolean
	public val direction: String
	public val snapToLines: Boolean
	public val linePosition: Number
	public val textPosition: Number
	public val size: Number
	public val alignment: String
	public val voice: String

	public fun getCueAsSource(): String
	public fun getCueAsHTML(): DocumentFragment
	public fun TimedTrackCue(id: String, startTime: Number, endTime: Number, settings: String, text: String, pauseOnExit: Boolean? = null): TimedTrackCue
}

public trait TimedTrackCueList {
	public val length: Number

	public fun getCueById(id: String): TimedTrackCue
}

public trait HTMLVideoElement : HTMLMediaElement {
	public var width: Number
	public var height: Number
	public val videoWidth: Number
	public val videoHeight: Number
	public var poster: String
}

public trait Database {
	public val version: String

	public fun transaction(callback: SQLTransactionCallback, errorCallback: SQLTransactionErrorCallback? = null, successCallback: SQLVoidCallback? = null): Unit
	public fun transaction(callback: SQLTransactionSyncCallback, errorCallback: SQLTransactionErrorCallback, successCallback: SQLVoidCallback): Unit
	public fun transaction(callback: ()->Unit, errorCallback: SQLTransactionErrorCallback, successCallback: SQLVoidCallback): Unit
	public fun readTransaction(callback: SQLTransactionCallback, errorCallback: SQLTransactionErrorCallback? = null, successCallback: SQLVoidCallback? = null): Unit
	public fun readTransaction(callback: SQLTransactionSyncCallback, errorCallback: SQLTransactionErrorCallback, successCallback: SQLVoidCallback): Unit
	public fun readTransaction(callback: ()->Unit, errorCallback: SQLTransactionErrorCallback, successCallback: SQLVoidCallback): Unit
	public fun changeVersion(oldVersion: String, newVersion: String, callback: SQLTransactionCallback? = null, errorCallback: SQLTransactionErrorCallback? = null, successCallback: SQLVoidCallback? = null): Unit
	public fun changeVersion(oldVersion: String, newVersion: String, callback: ()->Unit, errorCallback: SQLTransactionErrorCallback, successCallback: SQLVoidCallback): Unit
}

public trait SQLVoidCallback {
	public fun handleEvent(): Unit
}

public trait SQLTransactionCallback {
	public fun handleEvent(transaction: SQLTransaction? = null): Unit
}

public trait SQLTransactionErrorCallback {
	public fun handleEvent(error: SQLError? = null): Unit
}

public trait SQLTransaction {
	public fun executeSql(sqlStatement: String, arguments: Array<Any>? = null, callback: SQLStatementCallback? = null, errorCallback: SQLStatementErrorCallback? = null): Unit
}

public trait SQLStatementCallback {
	public fun handleEvent(transaction: SQLTransaction? = null, resultSet: SQLResultSet? = null): Unit
}

public trait SQLStatementErrorCallback {
	public fun handleEvent(transaction: SQLTransaction? = null, error: SQLError? = null): Boolean
}

public trait SQLTransactionSyncCallback {
	public fun handleEvent(transaction: SQLTransactionSync? = null): Unit
}

public trait SQLTransactionSync {
	public fun executeSql(sqlStatement: String, arguments: Array<Any>? = null): SQLResultSet
}

public trait SQLResultSet {
	public val insertId: Number
	public val rowsAffected: Number
	public val rows: SQLResultSetRowList
}

public trait SQLResultSetRowList {
	public val length: Int

	public fun item(index: Int): Unit
}

public trait SQLError {
	public class object {
		public val UNKNOWN_ERR: Int = 0
		public val DATABASE_ERR: Int = 1
		public val VERSION_ERR: Int = 2
		public val TOO_LARGE_ERR: Int = 3
		public val QUOTA_ERR: Int = 4
		public val SYNTAX_ERR: Int = 5
		public val CONSTRAINT_ERR: Int = 6
		public val TIMEOUT_ERR: Int = 7
	}
	public val code: Int
	public val message: String
}

public trait MessageEvent : Event {
	public val origin: String
	public val lastEventId: String
	public val source: Window
}

public trait HTMLCanvasElement : HTMLElement {
	public var width: Long
	public var height: Long

	public fun getContext(contextId: String, vararg args: Any?): CanvasRenderingContext2D
	public fun toDataURL(String: String? = null, args: Any? = null): String
}

public trait CanvasPattern {
	public fun setTransform(transform: SVGMatrix? = null): Unit
}

public trait SVGMatrix {
	public fun inverse(): Unit
}

public trait CanvasRenderingContext2D {
	public val canvas: HTMLCanvasElement
	public var globalAlpha: Float
	public var globalCompositeOperation: String
	public var fillStyle: Any
	public var strokeStyle: Any
	public var lineWidth: Number
	public var lineCap: String
	public var lineJoin: String
	public var miterLimit: Number
	public var shadowOffsetX: Number
	public var shadowOffsetY: Number
	public var shadowBlur: Number
	public var shadowColor: String
	public var font: String
	public var textAlign: String
	public var textBaseline: String

	public fun save(): Unit
	public fun restore(): Unit
	public fun scale(x: Float, y: Float): Unit
	public fun rotate(angle: Float): Unit
	public fun translate(x: Float, y: Float): Unit
	public fun transform(m11: Float, m12: Float, m21: Float, m22: Float, dx: Float, dy: Float): Unit
	public fun setTransform(m11: Float, m12: Float, m21: Float, m22: Float, dx: Float, dy: Float): Unit
	public fun createLinearGradient(x0: Float, y0: Float, x1: Float, y1: Float): CanvasGradient
	public fun createRadialGradient(x0: Float, y0: Float, r0: Float, x1: Float, y1: Float, r1: Float): CanvasGradient
	public fun createPattern(image: HTMLImageElement, repetition: String): CanvasPattern
	public fun createPattern(image: HTMLCanvasElement, repetition: String): CanvasPattern
	public fun createPattern(image: HTMLVideoElement, repetition: String): CanvasPattern
	public fun clearRect(x: Number, y: Number, w: Number, h: Number): Unit
	public fun fillRect(x: Number, y: Number, w: Number, h: Number): Unit
	public fun strokeRect(x: Number, y: Number, w: Number, h: Number): Unit
	public fun beginPath(): Unit
	public fun closePath(): Unit
	public fun moveTo(x: Number, y: Number): Unit
	public fun lineTo(x: Number, y: Number): Unit
	public fun quadraticCurveTo(cpx: Number, cpy: Number, x: Number, y: Number): Unit
	public fun bezierCurveTo(cp1x: Number, cp1y: Number, cp2x: Number, cp2y: Number, x: Number, y: Number): Unit
	public fun arcTo(x1: Number, y1: Number, x2: Number, y2: Number, radius: Number): Unit
	public fun rect(x: Number, y: Number, w: Number, h: Number): Unit
	public fun arc(x: Number, y: Number, radius: Number, startAngle: Number, endAngle: Number, anticlockwise: Boolean): Unit
	public fun fill(): Unit
	public fun stroke(): Unit
	public fun clip(): Unit
	public fun isPointInPath(x: Number, y: Number): Boolean
	public fun drawFocusRing(element: Element, xCaret: Number, yCaret: Number, canDrawCustom: Boolean? = null): Unit
	public fun fillText(text: String, x: Number, y: Number, maxWidth: Number? = null): Unit
	public fun strokeText(text: String, x: Number, y: Number, maxWidth: Number? = null): Unit
	public fun measureText(text: String): TextMetrics
	public fun drawImage(img_elem: Element, dx_or_sx: Number, dy_or_sy: Number, dw_or_sw: Number? = null, dh_or_sh: Number? = null, dx: Number? = null, dy: Number? = null, dw: Number? = null, dh: Number? = null): Unit
	public fun createImageData(imagedata_or_sw: ImageData, sh: Number? = null): ImageData
	public fun createImageData(imagedata_or_sw: Number, sh: Number): ImageData
	public fun getImageData(sx: Number, sy: Number, sw: Number, sh: Number): ImageData
	public fun putImageData(image_data: ImageData, dx: Number, dy: Number, dirtyX: Number? = null, dirtyY: Number? = null, dirtyWidth: Number? = null, dirtyHeight: Number? = null): Unit
}

public trait CanvasGradient {
	public fun addColorStop(offset: Number, color: String): Unit
}

public trait ImageData {
	public val data: CanvasPixelArray
	public val width: Number
	public val height: Number
}

public trait CanvasPixelArray {
	public val length: Number
}

public trait TextMetrics {
	public val width: Number
}

public trait WorkerNavigator {
}

public trait AbstractWorker {
	public var onerror: ()->Unit
}

public trait Transferable {
}

public class Worker(scriptURL: String) : AbstractWorker() {

override public var onerror: ()->Unit


	public abstract inner class MessageEvent : org.w3c.dom.Event {
		public val data: Any?
	}
	public var onmessage: (event: MessageEvent)->Unit

	public fun terminate(): Unit
	public fun postMessage(message: Any, transferList: Array<Transferable>? = null): Unit
}

public trait SharedWorker : AbstractWorker {
	public val port: ()->Unit
}

public trait Storage {
	public val length: Long

	public fun key(index: Long): String
	public fun getItem(key: String): Unit
	public fun setItem(key: String, data: String): Unit
	public fun setItem(key: String, data: Any): Unit
	public fun removeItem(key: String): Unit
	public fun clear(): Unit
}

public class WebSocket<T: Any>(url: String, vararg protocols: String) {
	public class object {
		public val CONNECTING: Int = 0
		public val OPEN: Int = 1
		public val CLOSING: Int = 2
		public val CLOSED: Int = 3
	}

	public var url: String
	public val readyState: Int
	public val bufferedAmount: Long
	public val extensions: String
	public val protocol: String
	public var onopen: (org.w3c.dom.Event)->Unit

	public abstract inner class MessageEvent : org.w3c.dom.Event {
		public val data: T
	}
	public var onmessage: (event: MessageEvent)->Unit
	public var onerror: (org.w3c.dom.Event)->Unit

	public abstract inner class CloseEvent : org.w3c.dom.Event {
		public val wasClean: Boolean
	}
	public var onclose: (event: CloseEvent)->Unit

	public fun send(data: String): Unit
	public fun send(data: ArrayBuffer): Unit
	public fun send(data: ArrayBufferView): Unit
	public fun send(data: Blob): Unit
	public fun close(code: Long? = null, reason: String? = null): Unit
}

public class ArrayBuffer(length: Long) {

	public var byteLength: Long

}

public class DataView(bufferOrArrayOrLength: Unit, byteOffset: Long? = null, length: Long? = null) {

	public val buffer: ArrayBuffer
	public val byteOffset: Long
	public val byteLength: Long

	public fun getInt8(byteOffset: Long? = null): Byte
}

public open class ArrayBufferView() {

	public val buffer: ArrayBuffer
	public val byteOffset: Long
	public val byteLength: Long

}

public class Int8Array(bufferOrArrayOrLength: Unit, byteOffset: Long? = null, length: Long? = null) : ArrayBufferView() {
	public class object {
		public val BYTES_PER_ELEMENT: Int = 8
	}

	public val length: Unit

	public fun set(array: Int8Array, offset: Long? = null): Unit
	public fun subarray(begin: Long, end: Long? = null): Int8Array
}

public class Uint8Array(bufferOrArrayOrLength: Unit, byteOffset: Long? = null, length: Long? = null) : ArrayBufferView() {
	public class object {
		public val BYTES_PER_ELEMENT: Int = 8
	}

	public val length: Long

	public fun set(array: Uint8Array, offset: Long? = null): Unit
	public fun subarray(begin: Long, end: Long? = null): Uint8Array
}

public class Int16Array(bufferOrArrayOrLength: Unit, byteOffset: Long? = null, length: Long? = null) : ArrayBufferView() {
	public class object {
		public val BYTES_PER_ELEMENT: Int = 16
	}

	public val length: Long

	public fun set(array: Int16Array, offset: Long? = null): Unit
	public fun subarray(begin: Long, end: Long? = null): Int16Array
}

public class Uint16Array(bufferOrArrayOrLength: Unit, byteOffset: Long? = null, length: Long? = null) : ArrayBufferView() {
	public class object {
		public val BYTES_PER_ELEMENT: Int = 16
	}

	public val length: Long

	public fun set(array: Uint16Array, offset: Long? = null): Unit
	public fun subarray(begin: Long, end: Long? = null): Uint16Array
}

public class Int32Array(bufferOrArrayOrLength: Unit, byteOffset: Long? = null, length: Long? = null) : ArrayBufferView() {
	public class object {
		public val BYTES_PER_ELEMENT: Int = 32
	}

	public val length: Long

	public fun set(array: Int32Array, offset: Long? = null): Unit
	public fun subarray(begin: Long, end: Long? = null): Int32Array
}

public class Uint32Array(bufferOrArrayOrLength: Unit, byteOffset: Number? = null, length: Number? = null) : ArrayBufferView() {
	public class object {
		public val BYTES_PER_ELEMENT: Int = 32
	}

	public val length: Long

	public fun set(array: Uint32Array, offset: Number? = null): Unit
	public fun subarray(begin: Number, end: Number? = null): Uint32Array
}

public class Float32Array(bufferOrArrayOrLength: Unit, byteOffset: Long? = null, length: Long? = null) : ArrayBufferView() {
	public class object {
		public val BYTES_PER_ELEMENT: Int = 32
	}

	public val length: Long

	public fun set(array: Float32Array, offset: Long? = null): Unit
	public fun subarray(begin: Long, end: Long? = null): Float32Array
}

public class Float64Array(bufferOrArrayOrLength: Long, byteOffset: Long? = null, length: Long? = null) : ArrayBufferView() {
	public class object {
		public val BYTES_PER_ELEMENT: Int = 64
	}

	public val length: Long

	public fun set(array: Float64Array, offset: Long? = null): Unit
	public fun subarray(begin: Long, end: Long? = null): Float64Array
}

public trait Geolocation {
	public fun getCurrentPosition(successCallback: ()->Unit, errorCallback: (()->Unit)? = null, options: Any? = null): Unit
	public fun watchPosition(successCallback: ()->Unit, errorCallback: (()->Unit)? = null, options: Any? = null): Number
	public fun clearWatch(watchId: Number? = null): Unit
}

public trait PositionOptions {
	public var enableHighAccuracy: Boolean
	public var timeout: Number
	public var maximumAge: Number
}

public trait Position {
	public var coords: Coordinates
	public var timestamp: Number
}

public trait Coordinates {
	public val latitude: Number
	public val longitude: Number
	public val altitude: Number
	public val accuracy: Number
	public val altitudeAccuracy: Number
	public val heading: Number
	public val speed: Number
}

public trait PositionError {
	public class object {
		public val PERMISSION_DENIED: Int = 1
		public val POSITION_UNAVAILABLE: Int = 2
		public val TIMEOUT: Int = 3
	}
	public val code: Int
	public val message: String
}

public trait XMLHttpRequestEventTarget : EventTarget {
	public var onloadstart: (org.w3c.dom.Event)->Unit
	public var onprogress: (org.w3c.dom.Event)->Unit
	public var onabort: (org.w3c.dom.Event)->Unit
	public var onerror: (org.w3c.dom.Event)->Unit
	public var onload: (org.w3c.dom.Event)->Unit
	public var ontimeout: (org.w3c.dom.Event)->Unit
	public var onloadend: (org.w3c.dom.Event)->Unit
}

public trait XMLHttpRequestUpload : XMLHttpRequestEventTarget {
}

public trait FormData {
	public fun append(name: String, value: Any): Unit
}

public trait ValidityState {
	public val valueMissing: Boolean
	public val typeMismatch: Boolean
	public val patternMismatch: Boolean
	public val tooLong: Boolean
	public val rangeUnderflow: Boolean
	public val rangeOverflow: Boolean
	public val stepMismatch: Boolean
	public val badInput: Boolean
	public val customError: Boolean
	public val valid: Boolean
}